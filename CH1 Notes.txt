Here you see another feature of the .NET Framework. You can use the Thread.CurrentThread
class to ask for information about the thread that’s executing. This is called the
thread’s *execution context*

If you want to use local data in a thread and initialize it for each thread, you can use the
ThreadLocal<T> class.

A thread’s current culture (a CultureInfo associated with the current thread that is used to format dates,
times, numbers, currency values, the sorting order of text, casing conventions, and string
comparisons), principal (representing the current security context), priority (a value to indicate
how the thread should be scheduled by the operating system), and other info.

 for example, a web server that serves incoming requests. All those requests come in
at an unknown time and frequency. The thread pool ensures that each request gets added to
the queue and that when a thread becomes available, it is processed. This ensures that your
server doesn’t crash under the amount of requests. If you span threads manually, you can
easily bring down your server if you get a lot of requests.

The Task can tell you if the work is completed and
if the operation returns a result, the Task gives you the result.
A task scheduler is responsible for starting the Task and managing it. By default, the Task
scheduler uses threads from the thread pool to execute the Task.

Tasks can be used to make your application more responsive. If the thread that manages
the user interface offloads work to another thread from the thread pool, it can keep processing
user events and ensure that the application can still be used. But it doesn’t help with scalability.
If a thread receives a web request and it would start a new Task, it would just consume
another thread from the thread pool while the original thread waits for results.

Attempting to read the Result property on a Task will force the thread that’s trying to
read the result to wait until the Task is finished before continuing. As long as the Task has not
finished, it is impossible to give the result. If the Task is not finished, this call will block the
current thread.

A TaskFactory is created with a certain configuration and can then be used to create Tasks with that configuration.

Instead of waiting until all tasks are finished, you can also wait until one of the tasks is
finished. You use the WaitAny method for this. 

The Parallel class has a couple of static methods—For, ForEach, and Invoke—
that you can use to parallelize work.


You can cancel the loop by using the ParallelLoopState object. You have two options to do
this: Break or Stop. Break ensures that all iterations that are currently running will be finished.
Stop just terminates everything.